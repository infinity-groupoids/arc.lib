
//////////////////////////////////////////////////////////////////////
// arc.lib - Generalized arc space construction for Singular
//////////////////////////////////////////////////////////////////////

version = "arc.lib 1.0.0 Sep_2025";
category = "Algebraic geometry";

info = "
LIBRARY: arc.lib  - Construct generalized arc spaces in Singular
AUTHOR:  Andrew R. Stout (astout@bmcc.cuny.edu)

DESCRIPTION:
  Computes the equations of a generalized arc space of a scheme defined by ideal I
  relative to a fat point defined by ideal J. Optionally, a skip list of coefficients can be provided. 

PROCEDURES:
  arc(I, J, optList); creates ring containing the ideal arcideal in the variables of T (excluding the original variables)
";

// LIB "arc.lib";



////////////////////////////////////////////////////////////////////////
// Main user-facing entry point with just 4 parameters
////////////////////////////////////////////////////////////////////////
proc arc(ideal I, ideal J, list optList)
"USAGE:
  arc(I, J, optList);

  I:       ideal defining the scheme
  J:       ideal defining the fat point
  optList: list of integers (optional), indices of coefficients to skip

RETURN:
  A ring containing the ideal arcideal in the variables of T (minus the original variables in Vars).

EXAMPLE:
  ring R = 0, (x,y), dp;
  ideal I = x^4 + y^3;
  ideal J = x^2,y^2;       // fat point at origin
  list L;                 //  optional skips
  def s = arc(I, J, L);
  setring s;
  ideal A = arcideal;
  A; 
RETURN: ring containing ideal arcideal in the variables of T"
{
    option(noredefine);

    ///////////
    // Determine whether to use the optional skip list
    ///////////
    int useOptList = 1;
    if (size(optList) == 0)
    {
        useOptList = 0;
    }
    else
    {
        for (int k = 1; k <= size(optList); k++)
        {
            if (optList[k] < 1)
            {
                useOptList = 0;
                break;
            }
        }
    }
    // Call arc_internal with explicit type conversion
    int useOptList_int = int(useOptList);
    return( arc_internal(I, J, optList, useOptList_int) );
}

////////////////////////////////////////////////////////////////////////
// Core implementation (no disk output, returns final ideal directly)
////////////////////////////////////////////////////////////////////////
proc arc_internal(ideal I, ideal J, list optList, int useOptList)
{
    option(noredefine);
    def R0 = basering;
    int N = nvars(R0);
    // Build comma-separated list of original variable names safely
    string v = varstr(1);
    for (int k1 = 2; k1 <= N; k1++)
    {
        v = v + "," + varstr(k1);
    }

    // Create helper ring with identical names, then import
    execute("ring Rhelp = 0, (" + v + "), dp;");
    setring Rhelp;
    ideal Ihelp = imap(R0, I);
    ideal Jhelp = imap(R0, J);
    int M = size(optList);

    if (Jhelp == 0) { print("Error: The ideal Jhelp is the zero ideal. Terminating."); return; }
     
    ///////////
    // Step 2: identify fat point variables
    ///////////
    ideal fatVars = (0);
    int flag1 = 0;
    poly currentVar;
    int jdx1;
    for (int idx1 = 1; idx1 <= N; idx1++)
    {
    flag1 = 0;
    currentVar = var(idx1);

    for (jdx1 = 1; jdx1 <= size(Jhelp); jdx1++)
    {
            intvec w = 0:N;
            w[idx1] = 1;
            if (deg(Jhelp[jdx1], w) > 0)          //A stricter test is to use reduced
            {
                flag1 = 1; break;
            }
        }
        if (flag1 == 1)
        {
            fatVars = fatVars + currentVar;
        }
    }

    ///////////
    // Step 3: store strings
    ///////////
    // Use original variable list 'v' captured from R0 when building Rhelp
    string T_vars = v;

    ///////////
    // Step 4: new ring F
    ///////////
    if (size(fatVars) == 0) { print("Warning: fatVars empty."); return; }
    string varsString = string(fatVars[1]);
    for (int idx3 = 2; idx3 <= size(fatVars); idx3++) {
        varsString = varsString + "," + string(fatVars[idx3]);
    }
    execute("ring F = 0, (" + varsString + "), dp;");
    execute("setring F;");
    option(noredefine);
    ideal J_F = imap(Rhelp, Jhelp);

    ///////////
    // Step 6: standard basis
    ///////////
    ideal G_F = std(J_F);

    ///////////
    // Step 7: use kbase
    ///////////
    ideal basis_JF_F = kbase(G_F);
    int len_JF       = size(basis_JF_F);

    ///////////
    // Step 8: new ring T
    ///////////
    int m = N * len_JF;
    if (m <= 0) { print("Error: fat point length < 2."); return; }
    for (int idx4 = 1; idx4 <= m; idx4++) {
        T_vars = T_vars + ",a" + string(idx4);
    }
    execute("ring T = 0, (" + T_vars + "), dp;");
    execute("setring T;");
    option(noredefine);

    
    ideal I_T        = imap(Rhelp, Ihelp);
    ideal G_T        = std( imap(F, G_F) );
    ideal basis_JF_T = imap(F, basis_JF_F);
    if (basis_JF_T[len_JF] != 1)
    {
        print("Error: last basis_JF_T != 1."); return;
    }

    ///////////
    // Step 9 build arcs
    ///////////
    list arcs;
    poly expr;
    int relIndex, global_idx, skip, temp, jdx2;
    for (int idx5 = 1; idx5 <= N; idx5++)
    {
        expr = 0;
        for (jdx2 = 1; jdx2 <= len_JF; jdx2++)
        {
            relIndex = (jdx2-1)*N + idx5;
            skip = 0;
            if (useOptList == 1)
            {
                for (temp = 1; temp <= size(optList); temp++)
                {
                    if (optList[temp] == relIndex)
                    {
                        skip = 1; break;
                    }
                }
            }
            if (skip == 0)
            {
                global_idx = N + relIndex;
                expr = expr + var(global_idx)*basis_JF_T[len_JF - jdx2 + 1];
            }
        }
        arcs = arcs + list(expr);
    }

    ///////////
    // Step 10: substitute arcs 
    ///////////
    string mapStr = "map substMap = T, (";
    int idx6;
    for (idx6 = 1; idx6 <= N; idx6++)
    {
        mapStr = mapStr + "(" + string(arcs[idx6]) + ")";
        if (idx6 < N)
        {
            mapStr = mapStr + ",";
        }
    }
    mapStr = mapStr + ");";
    execute(mapStr);
    ideal bigIdeal = substMap(I_T);

    ///////////
    // Step 11: reduce
    ///////////
    ideal reducedBigIdeal;
    for (idx6 = 1; idx6 <= size(bigIdeal); idx6++)
    {
        reducedBigIdeal = reducedBigIdeal + reduce(bigIdeal[idx6], G_T);
    }

    ///////////
    // Step 12: extract coefficients
    ///////////
    ideal arcideal = 0;
    poly f, term, basisElement;
    poly old_f, old_term;
    matrix coefMatrix;
    int basisIdx, i2, kdx8, optIdx, varIdx, shouldKeep;
    string varToFind, termStr;
    int ov = 0;

    for (kdx8 = 1; kdx8 <= size(reducedBigIdeal); kdx8++)
    {
        f = reducedBigIdeal[kdx8];
        
        for (basisIdx = 1; basisIdx < size(basis_JF_T); basisIdx++)
        {
            basisElement = basis_JF_T[basisIdx];
            
            coefMatrix = coef(f, basisElement);
            
            for (i2 = 1; i2 <= ncols(coefMatrix); i2++)
            {
                if (reduce(coefMatrix[1,i2], basisElement) == 0)
                {
                    if (nrows(coefMatrix) >= 2) {
                        term = coefMatrix[2,i2];
                    } else {
                        term = coefMatrix[1,i2];
                    }
                    
                    
                    for (ov = 1; ov <= N; ov++) {
                        if (deg(term, ov) > 0) {
                            // Extract all coefficients including constants
                            coefMatrix = coeffs(term, var(ov));
                            poly result = 0;
                            // Process all columns in the matrix to capture every coefficient
                            for (int i = 1; i <= ncols(coefMatrix); i++) {
                                result = result + coefMatrix[2,i];
                            }
                            term = result;
                        }
                    }
                    
                    shouldKeep = 1;
                    if (useOptList == 1)
                    {
                        for (optIdx=1; optIdx<=size(optList); optIdx++)
                        {
                            varIdx = optList[optIdx];
                            varToFind = "a"+string(varIdx)+"*";
                            termStr   = string(term)+"*";
                            if (find(termStr,varToFind)!=0)
                            {
                                shouldKeep = 0;
                                break;
                            }
                        }
                    }
                    if (shouldKeep == 1)
                    {
                        arcideal = arcideal + term;
                    }
                }
            }
            
            for (i2=1; i2<=ncols(coefMatrix); i2++)
            {
                if (reduce(coefMatrix[1,i2], basis_JF_T[basisIdx])==0 && nrows(coefMatrix)>=2)
                {
                    f = f - coefMatrix[2,i2]*coefMatrix[1,i2];
                }
            }
        }
        
        if (f!=0 && f!=1)
        {
            
            for (ov = 1; ov <= N; ov++) {
                if (deg(f, ov) > 0) {
                    f = coef(f, var(ov))[2,1];
                }
            }
            
            shouldKeep = 1;
            if (useOptList==1)
            {
                for (optIdx=1; optIdx<=size(optList); optIdx++)
                {
                    varIdx = optList[optIdx];
                    if (varIdx <= 0) { continue; }  // Skip invalid indices
                    
                    varToFind = "a"+string(varIdx)+"*";
                    termStr   = string(f)+"*";
                    if (find(termStr,varToFind)!=0)
                    {
                        shouldKeep = 0;
                        break;
                    }
                }
            }
            if (shouldKeep == 1)
            {
                arcideal = arcideal + f;
            }
        }
    }

    ///////////
    // cleanup
    ///////////
    poly ct;
    ideal simplifiedFinal = 0;
    int shouldKeep, i2;
    string varToFind, termStr;

    for (i2 = 1; i2 <= size(arcideal); i2++)
    {
        ct = arcideal[i2];
        
        shouldKeep = 1;
        if (useOptList == 1)
        {
            for (optIdx=1; optIdx<=size(optList); optIdx++)
            {
                varToFind = "a" + string(optList[optIdx]) + "*";
                termStr   = string(ct) + "*";
                if (find(termStr, varToFind) != 0)
                {
                    shouldKeep = 0;
                    break;
                }
            }
        }

        ///////////
        // Skip terms that contain any of the original variables (first N variables)
        ///////////
        if (shouldKeep == 1)
        {
            string ctString = string(ct);
            for (int varIdx = 1; varIdx <= N; varIdx++)
            {
                string originalVar = varstr(varIdx);
                if (find(ctString, originalVar) != 0)
                {
                    shouldKeep = 0;
                    break;
                }
            }
        }
        
        if (shouldKeep == 1)
        {
            simplifiedFinal = simplifiedFinal + ct;
        }
    }

     ///////////
    // Reverse order for better output
    ///////////
    ideal arcideal = 0;
    for (int i = size(simplifiedFinal); i >= 1; i--) {
    arcideal = arcideal + simplifiedFinal[i];
    }
    arcideal = arcideal;


    ///////////
    // Create filtered variable list with effective variables used in arcideal
    ///////////
    string filtered_vars = "";
    
    ///////////
    // First collect all variables from N+1 to nvars(basering)
    ///////////
    list allVars;
    for (int var_idx = N+1; var_idx <= nvars(basering); var_idx++) {
        // Skip variables mentioned in optList
        int skip_var = 0;
        if (useOptList == 1) {
            for (optIdx = 1; optIdx <= size(optList); optIdx++) {
                if (var_idx == N + optList[optIdx]) {
                    skip_var = 1;
                    break;
                }
            }
        }
        
        if (skip_var == 0) {
            allVars = allVars + list(varstr(var_idx));
        }
    }
    
    ///////////
    // Now check every generator of arcideal for each variable
    ///////////
    list usedVars;
    for (int genIdx = 1; genIdx <= size(arcideal); genIdx++) {
        string genStr = string(arcideal[genIdx]);
        
        for (int i = 1; i <= size(allVars); i++) {
            string varName = allVars[i];
            
            // Check various ways the variable might appear in the polynomial
            if (find(genStr, varName + "*") != 0 || // Middle of term
                find(genStr, varName + "^") != 0 || // With power
                find(genStr, "+" + varName) != 0 || // At start after +
                find(genStr, "-" + varName) != 0 || // At start after -
                find(genStr, "*" + varName) != 0 || // After multiplication
                find(genStr, "(" + varName) != 0 || // After parenthesis
                genStr == varName ||                // Entire generator is this variable
                find(genStr + "+", varName + "+") != 0) { // At end before +
                // Add to used vars if not already there
                int found = 0;
                for (int j = 1; j <= size(usedVars); j++) {
                    if (usedVars[j] == varName) {
                        found = 1;
                        break;
                    }
                }
                if (found == 0) {
                    usedVars = usedVars + list(varName);
                }
            }
        }
    }
    
    ///////////
    // Convert used variables list to comma-separated string
    ///////////
    if (size(usedVars) > 0) {
        filtered_vars = usedVars[1];
        for (int i = 2; i <= size(usedVars); i++) {
            filtered_vars = filtered_vars + "," + usedVars[i];
        }
    } else {
        // If no variables were found, just use a1 as a placeholder
        filtered_vars = "a1";
    }

    // Build a result ring with ONLY the arc coefficient variables (remove first N)
    string arcideal_str = string(arcideal);

    // Build comma-separated list of coefficient variables (excluding optList)
    string coeff_vars = "";
    if (size(allVars) > 0) {
        coeff_vars = allVars[1];
        for (int i = 2; i <= size(allVars); i++) {
            coeff_vars = coeff_vars + "," + allVars[i];
        }
    } else {
        coeff_vars = "a1";
    }

    setring R0;
    execute("ring S_coeff = 0, (" + coeff_vars + "), dp;");
    execute("setring S_coeff;");
    execute("ideal arcideal = " + arcideal_str + ";");
    execute("export arcideal;");

    def retRing = basering;
    keepring retRing;
    return(retRing);
}